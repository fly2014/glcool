<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>NET &#8211; GlCool</title>
	<atom:link href="https://www.glcool.com/archives/category/net/feed" rel="self" type="application/rss+xml" />
	<link>http://www.glcool.com/</link>
	<description>The Global Coolest</description>
	<lastBuildDate>Thu, 28 May 2020 05:21:54 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.4.1</generator>
	<item>
		<title>C#动态编译表达式</title>
		<link>https://www.glcool.com/archives/308</link>
					<comments>https://www.glcool.com/archives/308#respond</comments>
		
		<dc:creator><![CDATA[flying]]></dc:creator>
		<pubDate>Fri, 08 Nov 2019 06:00:27 +0000</pubDate>
				<category><![CDATA[NET]]></category>
		<category><![CDATA[动态编译]]></category>
		<guid isPermaLink="false">https://www.glcool.com/?p=308</guid>

					<description><![CDATA[下面是原始方案 public object ComplierCode(string expression, I &#8230; <a href="https://www.glcool.com/archives/308" class="more-link">继续阅读<span class="screen-reader-text">C#动态编译表达式</span></a>]]></description>
										<content:encoded><![CDATA[<p>下面是原始方案<br />
public object ComplierCode(string expression, ILogService logService, out string errorString)<br />
        {<br />
            string code = WrapExpression(expression);<br />
            object retvalue = null;<br />
            errorString = &#8220;&#8221;;<br />
            CSharpCodeProvider csharpCodeProvider = new CSharpCodeProvider();<br />
            try<br />
            {<br />
                //编译的参数<br />
                CompilerParameters compilerParameters = new CompilerParameters<br />
                {<br />
                    CompilerOptions = &#8220;/t:library&#8221;,<br />
                    GenerateInMemory = true<br />
                };<br />
                //开始编译<br />
                CompilerResults compilerResults = csharpCodeProvider.CompileAssemblyFromSource(compilerParameters, code);<br />
                if (compilerResults.Errors.Count > 0)<br />
                {<br />
                    StringBuilder sb = new StringBuilder();<br />
                    for (int i = 0; i < compilerResults.Errors.Count; i++)
                    {
                        sb.Append(sb.Length > 0 ? &#8220;;&#8221; : &#8220;&#8221;);<br />
                        sb.Append(compilerResults.Errors[i].ErrorText);<br />
                    }<br />
                    errorString = sb.ToString();<br />
                    throw new Exception(&#8220;编译出错！&#8221; + sb.ToString());<br />
                }</p>
<p>                Assembly assembly = compilerResults.CompiledAssembly;<br />
                Type type = assembly.GetType(&#8220;ExpressionCalculate&#8221;);<br />
                MethodInfo method = type.GetMethod(&#8220;Calculate&#8221;);<br />
                retvalue = method.Invoke(null, null);<br />
            }<br />
            catch (Exception ex)<br />
            {<br />
                logService.WriteLog(&#8220;编译出错,code=&#8221; + code, ex);<br />
            }<br />
            finally<br />
            {<br />
                csharpCodeProvider.Dispose();<br />
            }<br />
            return retvalue;<br />
        }</p>
<p>        private string WrapExpression(string expression)<br />
        {<br />
            string code = @&#8221;<br />
                using System;</p>
<p>                class ExpressionCalculate<br />
                {<br />
                    public static object Calculate()<br />
                    {<br />
                        return {0};<br />
                    }<br />
                }<br />
            &#8220;;<br />
            return code.Replace(&#8220;{0}&#8221;, expression);<br />
        }<br />
其他方案：https://github.com/davideicardi/DynamicExpresso</p>
]]></content:encoded>
					
					<wfw:commentRss>https://www.glcool.com/archives/308/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Linux CentOS7安装NET Core</title>
		<link>https://www.glcool.com/archives/297</link>
					<comments>https://www.glcool.com/archives/297#respond</comments>
		
		<dc:creator><![CDATA[flying]]></dc:creator>
		<pubDate>Thu, 08 Aug 2019 09:11:46 +0000</pubDate>
				<category><![CDATA[NET]]></category>
		<category><![CDATA[CentOS7]]></category>
		<category><![CDATA[NET Core]]></category>
		<guid isPermaLink="false">https://www.glcool.com/?p=297</guid>

					<description><![CDATA[sudo rpm -Uvh https://packages.microsoft.com/config/rhe &#8230; <a href="https://www.glcool.com/archives/297" class="more-link">继续阅读<span class="screen-reader-text">Linux CentOS7安装NET Core</span></a>]]></description>
										<content:encoded><![CDATA[<p>sudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm<br />
sudo yum update<br />
sudo yum install dotnet-sdk-2.2-2.2.108-1</p>
<p>安装守护进程<br />
yum install supervisor<br />
systemctl enable supervisord.service<br />
systemctl start supervisord.service<br />
systemctl status supervisord.service<br />
vi /etc/supervisord.conf(修改9001端口注释，打开防火墙，重启)<br />
systemctl restart supervisord.service<br />
参考：https://my.oschina.net/weidedong/blog/747428</p>
]]></content:encoded>
					
					<wfw:commentRss>https://www.glcool.com/archives/297/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>C#动态执行javascript</title>
		<link>https://www.glcool.com/archives/294</link>
					<comments>https://www.glcool.com/archives/294#respond</comments>
		
		<dc:creator><![CDATA[flying]]></dc:creator>
		<pubDate>Wed, 07 Aug 2019 09:32:25 +0000</pubDate>
				<category><![CDATA[NET]]></category>
		<category><![CDATA[javascript]]></category>
		<guid isPermaLink="false">https://www.glcool.com/?p=294</guid>

					<description><![CDATA[Create a file in Notepad with only these contents: clas &#8230; <a href="https://www.glcool.com/archives/294" class="more-link">继续阅读<span class="screen-reader-text">C#动态执行javascript</span></a>]]></description>
										<content:encoded><![CDATA[<p>Create a file in Notepad with only these contents:</p>
<p>class EvalClass { function Evaluate(expression: String) { return eval(expression); } }<br />
Save the file as C:\MyEval.js</p>
<p>Open a VS2005 Command Prompt (Start, Programs, VS2005, VS2005 Tools)</p>
<p>Type Cd\ to get to C:\</p>
<p>Type</p>
<p>jsc /t:library C:\MyEval.js<br />
A new file is created named MyEval.dll.</p>
<p>Copy MyEval.dll to the project and reference it (also reference Microsoft.Jscript.dll).</p>
<p>Then you should be able to call it like this:</p>
<p>Dim jScriptEvaluator As New EvalClass<br />
Dim objResult As Object<br />
objResult = jScriptEvaluator.Evaluate(“1==1 &amp;&amp; 2==2”)<br />
其他方式：https://github.com/davideicardi/DynamicExpresso（支持netcore）</p>
]]></content:encoded>
					
					<wfw:commentRss>https://www.glcool.com/archives/294/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>NET之NLOG使用</title>
		<link>https://www.glcool.com/archives/278</link>
					<comments>https://www.glcool.com/archives/278#respond</comments>
		
		<dc:creator><![CDATA[flying]]></dc:creator>
		<pubDate>Tue, 09 Jul 2019 03:19:47 +0000</pubDate>
				<category><![CDATA[NET]]></category>
		<category><![CDATA[NLOG]]></category>
		<guid isPermaLink="false">https://www.glcool.com/?p=278</guid>

					<description><![CDATA[安装 Install-Package NLog.Config 配置文件 &#60;nlog xmlns="htt &#8230; <a href="https://www.glcool.com/archives/278" class="more-link">继续阅读<span class="screen-reader-text">NET之NLOG使用</span></a>]]></description>
										<content:encoded><![CDATA[<p>安装<br />
<code>Install-Package NLog.Config</code><br />
配置文件</p>
<pre>  &lt;nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.nlog-project.org/schemas/NLog.xsd NLog.xsd"
      autoReload="true"
      throwExceptions="false"
      internalLogLevel="Trace" internalLogToConsole="false" internalLogFile="nlog-internal.log"&gt;
  &lt;targets  async="true"&gt;
    &lt;target name="logfile" xsi:type="File" fileName="file.txt" /&gt;
    &lt;target name="logconsole" xsi:type="Console" /&gt;
  &lt;/targets&gt;
  &lt;rules&gt;
    &lt;logger name="*" minlevel="Info" writeTo="logconsole,logfile" /&gt;
    &lt;logger name="*" minlevel="Debug" writeTo="logconsole" /&gt;
    &lt;logger name="*" minlevel="Error" writeTo="logconsole,logfile" /&gt;
  &lt;/rules&gt;
&lt;/nlog&gt;  
</pre>
<p>使用<br />
<code>public static readonly NLog.Logger Logger = NLog.LogManager.GetCurrentClassLogger();<br />
Logger.Error("Error" + (e.Source as AccordionStyleControl).Tag.ToString());</code></p>
]]></content:encoded>
					
					<wfw:commentRss>https://www.glcool.com/archives/278/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>C# winform 自定义透明控件，可以重叠</title>
		<link>https://www.glcool.com/archives/258</link>
					<comments>https://www.glcool.com/archives/258#respond</comments>
		
		<dc:creator><![CDATA[flying]]></dc:creator>
		<pubDate>Thu, 06 Jun 2019 06:08:59 +0000</pubDate>
				<category><![CDATA[NET]]></category>
		<category><![CDATA[C#]]></category>
		<category><![CDATA[winform]]></category>
		<category><![CDATA[透明控件]]></category>
		<guid isPermaLink="false">https://www.glcool.com/?p=258</guid>

					<description><![CDATA[直接上代码： using System; using System.Collections.Generic;  &#8230; <a href="https://www.glcool.com/archives/258" class="more-link">继续阅读<span class="screen-reader-text">C# winform 自定义透明控件，可以重叠</span></a>]]></description>
										<content:encoded><![CDATA[<p>直接上代码：<br />
<code><br />
using System;<br />
using System.Collections.Generic;<br />
using System.ComponentModel;<br />
using System.Drawing;<br />
using System.Data;<br />
using System.Linq;<br />
using System.Text;<br />
using System.Threading.Tasks;<br />
using System.Windows.Forms;<br />
using System.Drawing.Drawing2D;<br />
using System.Runtime.InteropServices;<br />
using System.Drawing.Imaging;</code></p>
<p>namespace WFControl<br />
{<br />
public partial class ArrowLine : UserControl<br />
{<br />
<span style="color: #ff0000;">protected override CreateParams CreateParams</span><br />
<span style="color: #ff0000;">{</span><br />
<span style="color: #ff0000;">get</span><br />
<span style="color: #ff0000;">{</span><br />
<span style="color: #ff0000;">CreateParams cp = base.CreateParams;</span><br />
<span style="color: #ff0000;">cp.ExStyle |= 0x00000020;</span><br />
<span style="color: #ff0000;">return cp;</span><br />
<span style="color: #ff0000;">}</span><br />
<span style="color: #ff0000;">}</span><br />
public ArrowLine()<br />
{<br />
InitializeComponent();<br />
<span style="color: #ff0000;">[subscribe]this.SetStyle(ControlStyles.SupportsTransparentBackColor | ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint | ControlStyles.Opaque, true);[/subscribe]</span><br />
this.SetStyle(ControlStyles.ResizeRedraw, false);<br />
}<br />
private int mlineHeight = 5;<br />
private byte mdirection = 0;</p>
<p>///</p>
<p>/// 线条宽度.<br />
///</p>
<p>[Description(&#8220;宽度&#8221;)]</p>
<p>public int LineHeight<br />
{<br />
get<br />
{<br />
return mlineHeight;<br />
}<br />
set<br />
{<br />
mlineHeight = value;<br />
}<br />
}<br />
private int mIsArrow = 0;<br />
///</p>
<p>/// 是否显示箭头.<br />
///</p>
<p>[Description(&#8220;箭头&#8221;)]<br />
public int IsArrow<br />
{<br />
get { return mIsArrow; }<br />
set<br />
{<br />
mIsArrow = value;<br />
}<br />
}<br />
///</p>
<p>/// 线条方向<br />
///0:从右至左;1:从下至上；2：从左至右;3:从上至下.<br />
///</p>
<p>[Description(&#8220;类型&#8221;)]</p>
<p>public byte Direction<br />
{<br />
get<br />
{<br />
return mdirection;<br />
}<br />
set<br />
{<br />
mdirection = value;<br />
}<br />
}<br />
[Description(&#8220;颜色&#8221;)]<br />
public Color color<br />
{<br />
get;<br />
set;<br />
}<br />
protected override void OnPaint(PaintEventArgs e)<br />
{<br />
Color drawColor = Color.FromArgb(0, Color.Purple);<br />
Brush brush = new SolidBrush(drawColor);</p>
<p>Pen pen = new Pen(this.color);<br />
pen.Width = LineHeight;<br />
AdjustableArrowCap aac = null;<br />
AdjustableArrowCap aac1 = null;<br />
if (mIsArrow == 1)<br />
{<br />
aac = new AdjustableArrowCap(4, 2);<br />
pen.CustomStartCap = aac;<br />
}<br />
if (mIsArrow == 2)<br />
{<br />
aac = new AdjustableArrowCap(4, 2);<br />
pen.CustomEndCap = aac;<br />
}<br />
if (mIsArrow == 3)<br />
{<br />
aac = new AdjustableArrowCap(4, 2);<br />
aac1 = new AdjustableArrowCap(4, 2);<br />
pen.CustomStartCap = aac;<br />
pen.CustomEndCap = aac1;<br />
}</p>
<p>int lenWidth = mlineHeight;<br />
int x1 = 0;<br />
int y1 = 0;<br />
int x2 = 0;<br />
int y2 = 0;<br />
if (Direction == 0)<br />
{<br />
// 0:从右至左; 1:从下至上；2：从左至右; 3:从上至下.<br />
x1 = this.Size.Width;<br />
y1 = this.Size.Height / 2;<br />
x2 = 0;<br />
y2 = y1;<br />
}<br />
else if (Direction == 1)<br />
{<br />
x1 = this.Size.Width / 2;<br />
y1 = this.Size.Height;<br />
x2 = x1;<br />
y2 = 0;<br />
}<br />
else if (Direction == 2)<br />
{<br />
//2：从左至右;<br />
x1 = 0;<br />
y1 = this.Size.Height / 2;<br />
x2 = this.Size.Width;<br />
y2 = y1;<br />
}<br />
else if (Direction == 3)<br />
{<br />
//3:从上至下.<br />
x1 = this.Size.Width / 2;<br />
y1 = 0;<br />
x2 = x1;<br />
y2 = this.Size.Height;<br />
}</p>
<p>//e.Graphics.FillRectangle(brush, 0, 0, this.Size.Width, this.Size.Height);<br />
e.Graphics.DrawLine(pen, x1, y1, x2, y2);<br />
pen.Dispose();<br />
if (mIsArrow == 1 || mIsArrow == 2)<br />
{<br />
aac.Dispose();<br />
}<br />
if (mIsArrow == 3)<br />
{<br />
aac.Dispose();<br />
aac1.Dispose();<br />
}<br />
brush.Dispose();<br />
}<br />
}<br />
}</p>
]]></content:encoded>
					
					<wfw:commentRss>https://www.glcool.com/archives/258/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
